<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SafeZone Dev - Real Time Tracking</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="icon" type="image/png" href="../images/safezone icone.png">
</head>
<body class="tracking-page dev-page">
    <header class="header">
        <div class="header-left">
            <button class="menu-btn" id="menuBtn">‚ò∞</button>
            <img src="/images/safezone icone.png" alt="SafeZone Logo" class="header-logo white-fill">
        </div>

        <div class="header-right">
            <button class="header-btn" data-nav="notifications">
                <span class="bell-icon">üîî</span>
                <span class="notification-badge" id="notificationBadge">0</span>
            </button>
            <button class="header-btn" data-nav="profile">
                <span class="user-icon">üë§</span>
            </button>
        </div>

        <div class="dropdown-menu" id="dropdownMenu">
            <a href="/html/page2_dashboard.html">Dashboard</a>
            <a href="/html/page13_farm-management.html">Farm Management</a>
            <a href="/html/page8_farm-information.html">Farm Information</a>
            <a href="/html/page14_farm-and-fence.html">Farm and Fence</a>
            <a href="/html/page19_dev-real-time-tracking.html" class="active">Dev Real-time Tracking</a>
            <a href="/html/page10_customize-alerts.html">Customize Alerts</a>
        </div>
    </header>

    <main class="main-content">
        <div class="farm-display-header">
            <h2 id="currentFarmName">Developer - Real Time Tracking</h2>
        </div>

        <div class="farm-selection-panel">
            <h3>Select Farm to View:</h3>
            <div class="farm-radio-group" id="farmRadioGroup">
                <!-- Farm radio buttons will be loaded here dynamically -->
            </div>
        </div>

        <div class="visibility-controls-panel">
            <h3>Map Display Options:</h3>
            <div class="visibility-toggles">
                <label class="toggle-container">
                    <input type="checkbox" id="toggleFarmMarkers" checked onchange="toggleFarmMarkersVisibility(this.checked)">
                    <span class="toggle-slider"></span>
                    <span class="toggle-label">Show Farm GPS Markers</span>
                </label>
                <label class="toggle-container">
                    <input type="checkbox" id="toggleFences" checked onchange="toggleFencesVisibility(this.checked)">
                    <span class="toggle-slider"></span>
                    <span class="toggle-label">Show Fence Lines</span>
                </label>
                <label class="toggle-container">
                    <input type="checkbox" id="toggleCowNameDisplay" onchange="toggleCowNameDisplayMode(this.checked)">
                    <span class="toggle-slider"></span>
                    <span class="toggle-label">Show Cow Nicknames</span>
                </label>
            </div>
        </div>

        <div class="tracking-controls">
            <div class="control-group">
                <button class="btn btn-primary" onclick="window.location.href='edit-fences.html'">
                    Farm and Fence
                </button>

                <button class="btn btn-secondary" onclick="autoFocusFence()">
                    Auto Focus Fence
                </button>

                <button class="btn btn-secondary" onclick="autoFocusAll()">
                    Auto Focus All
                </button>

                <button class="btn btn-danger" onclick="openRecoveryModal()" style="background: #e74c3c; border-color: #c0392b;">
                    Cow Recovery
                </button>

                <button class="btn btn-primary" onclick="refreshCowPositions()" title="Reload cow positions from database">
                    üîÑ Refresh Cows
                </button>
            </div>

            <div class="dropdown-controls">
                <div class="dropdown">
                    <button class="dropdown-btn" onclick="toggleDropdown('fenceDropdown')">
                        Fence List ‚ñº
                    </button>
                    <div class="dropdown-content" id="fenceDropdown">
                        <div class="fence-item" onclick="selectFence('fence1')">
                            North Pasture - Farm A
                        </div>
                        <div class="fence-item" onclick="selectFence('fence2')">
                            South Field - Farm A
                        </div>
                        <div class="fence-item" onclick="selectFence('fence3')">
                            East Meadow - Farm B
                        </div>
                    </div>
                </div>

                <div class="dropdown">
                    <button class="dropdown-btn" onclick="toggleDropdown('cowDropdown')">
                        Cow List ‚ñº
                    </button>
                    <div class="dropdown-content" id="cowDropdown">
                        <div class="cow-item">
                            <div class="cow-info">
                                <span class="cow-id">Cow #C001</span>
                                <div class="cow-controls">
                                    <label class="switch">
                                        <input type="checkbox" checked onchange="toggleCowVisibility('C001', this)">
                                        <span class="slider"></span>
                                    </label>
                                    <label class="checkbox-container">
                                        <input type="checkbox" onchange="toggleAlarm('C001', this)">
                                        <span class="checkmark"></span>
                                        <span class="label-text">Alarm</span>
                                    </label>
                                    <label class="checkbox-container">
                                        <input type="checkbox" onchange="toggleMarker('C001', this)">
                                        <span class="checkmark"></span>
                                        <span class="label-text">Marker</span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="cow-item">
                            <div class="cow-info">
                                <span class="cow-id">Cow #C002</span>
                                <div class="cow-controls">
                                    <label class="switch">
                                        <input type="checkbox" checked onchange="toggleCowVisibility('C002', this)">
                                        <span class="slider"></span>
                                    </label>
                                    <label class="checkbox-container">
                                        <input type="checkbox" onchange="toggleAlarm('C002', this)">
                                        <span class="checkmark"></span>
                                        <span class="label-text">Alarm</span>
                                    </label>
                                    <label class="checkbox-container">
                                        <input type="checkbox" onchange="toggleMarker('C002', this)">
                                        <span class="checkmark"></span>
                                        <span class="label-text">Marker</span>
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="cow-item">
                            <div class="cow-info">
                                <span class="cow-id">Cow #C003</span>
                                <div class="cow-controls">
                                    <label class="switch">
                                        <input type="checkbox" checked onchange="toggleCowVisibility('C003', this)">
                                        <span class="slider"></span>
                                    </label>
                                    <label class="checkbox-container">
                                        <input type="checkbox" onchange="toggleAlarm('C003', this)">
                                        <span class="checkmark"></span>
                                        <span class="label-text">Alarm</span>
                                    </label>
                                    <label class="checkbox-container">
                                        <input type="checkbox" onchange="toggleMarker('C003', this)">
                                        <span class="checkmark"></span>
                                        <span class="label-text">Marker</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- New Cows List Panel -->
        <div class="new-cows-panel" id="newCowsPanel" style="display: none;">
            <div class="panel-header">
                <h3>New Cows (Unassigned)</h3>
                <button class="close-panel-btn" onclick="closeNewCowsPanel()">&times;</button>
            </div>
            <div class="new-cows-list" id="newCowsList">
                <p class="loading-message">Loading new cows...</p>
            </div>
        </div>

        <style>
            .new-cows-panel {
                background: white;
                border-radius: 8px;
                padding: 1.5rem;
                margin: 1rem 0;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                border-left: 4px solid #f39c12;
            }

            .panel-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
                padding-bottom: 0.5rem;
                border-bottom: 2px solid #f39c12;
            }

            .panel-header h3 {
                margin: 0;
                color: #2c3e50;
            }

            .close-panel-btn {
                background: none;
                border: none;
                font-size: 1.5rem;
                cursor: pointer;
                color: #95a5a6;
                transition: color 0.3s;
            }

            .close-panel-btn:hover {
                color: #e74c3c;
            }

            .new-cows-list {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 1rem;
            }

            .new-cow-card {
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 6px;
                padding: 1rem;
            }

            .new-cow-card h4 {
                margin: 0 0 0.5rem 0;
                color: #2c3e50;
            }

            .new-cow-info {
                font-size: 0.9rem;
                color: #666;
                margin-bottom: 0.5rem;
            }

            .assign-farm-select {
                width: 100%;
                padding: 0.5rem;
                margin: 0.5rem 0;
                border: 1px solid #ddd;
                border-radius: 4px;
            }

            .assign-btn {
                width: 100%;
                padding: 0.5rem;
                background: #3498db;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                transition: background 0.3s;
            }

            .assign-btn:hover {
                background: #2980b9;
            }

            .bulk-assign-section {
                background: #e8f4f8;
                padding: 1rem;
                border-radius: 6px;
                margin-bottom: 1rem;
            }

            .bulk-assign-section h4 {
                margin-top: 0;
            }

            .bulk-controls {
                display: flex;
                gap: 0.5rem;
                align-items: center;
            }

            .bulk-controls select {
                flex: 1;
                padding: 0.5rem;
                border: 1px solid #ddd;
                border-radius: 4px;
            }

            .bulk-controls button {
                padding: 0.5rem 1rem;
                background: #2ecc71;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                white-space: nowrap;
            }

            .bulk-controls button:hover {
                background: #27ae60;
            }

            /* Compact Virtual Controller Styles */
            .controller-sidebar {
                width: 220px;
                background: #1a1a1a;
                border: 2px solid #2c3e50;
                border-radius: 8px;
                padding: 12px;
                color: #ecf0f1;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                height: fit-content;
                max-height: 600px;
                overflow-y: auto;
            }

            .controller-section {
                margin-bottom: 12px;
                padding-bottom: 10px;
                border-bottom: 1px solid #34495e;
            }

            .controller-section:last-child {
                border-bottom: none;
            }

            .direction-pad-compact {
                display: flex;
                flex-direction: column;
                gap: 3px;
                align-items: center;
                margin-top: 5px;
            }

            .dir-btn-compact {
                width: 50px;
                height: 40px;
                background: #34495e;
                border: 1px solid #7f8c8d;
                border-radius: 4px;
                color: #ecf0f1;
                font-size: 16px;
                cursor: pointer;
                transition: all 0.2s;
                user-select: none;
            }

            .dir-btn-compact:hover {
                background: #3498db;
                border-color: #2980b9;
            }

            .dir-btn-compact:active {
                background: #2980b9;
                transform: scale(0.95);
            }

            #virtualJoystick {
                position: relative;
                touch-action: none;
            }

            #virtualJoystickKnob {
                transition: all 0.1s ease;
            }

            #virtualJoystickKnob:active {
                cursor: grabbing;
            }

            .connection-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                display: inline-block;
            }

            .connection-indicator.connected {
                background: #27ae60;
                box-shadow: 0 0 8px #27ae60;
            }

            .connection-indicator.disconnected {
                background: #95a5a6;
            }

            input[type="range"] {
                -webkit-appearance: none;
                appearance: none;
                height: 6px;
                background: #34495e;
                border-radius: 3px;
                outline: none;
            }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 16px;
                height: 16px;
                background: #3498db;
                cursor: pointer;
                border-radius: 50%;
            }

            input[type="range"]::-moz-range-thumb {
                width: 16px;
                height: 16px;
                background: #3498db;
                cursor: pointer;
                border-radius: 50%;
                border: none;
            }

            /* Scrollbar styling for sidebar */
            .controller-sidebar::-webkit-scrollbar {
                width: 6px;
            }

            .controller-sidebar::-webkit-scrollbar-track {
                background: #2c3e50;
                border-radius: 3px;
            }

            .controller-sidebar::-webkit-scrollbar-thumb {
                background: #34495e;
                border-radius: 3px;
            }

            .controller-sidebar::-webkit-scrollbar-thumb:hover {
                background: #3498db;
            }

            /* Responsive design for mobile */
            @media (max-width: 768px) {
                .tracking-layout {
                    flex-direction: column;
                }

                .controller-sidebar {
                    width: 100%;
                    max-height: 400px;
                    margin-top: 1rem;
                }

                .alarm-panel {
                    width: 100%;
                    margin-top: 1rem;
                }
            }

            /* Create Virtual Cow Button */
            .btn-create-cow {
                width: 100%;
                padding: 8px;
                background: #27ae60;
                color: #ecf0f1;
                border: 1px solid #229954;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }

            .btn-create-cow:hover {
                background: #229954;
                box-shadow: 0 0 8px rgba(39, 174, 96, 0.5);
            }

            .btn-create-cow:active {
                transform: scale(0.98);
            }

            /* Cow Recovery Button */
            .btn-recovery {
                width: 100%;
                padding: 8px;
                background: #e74c3c;
                color: #ecf0f1;
                border: 1px solid #c0392b;
                border-radius: 4px;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }

            .btn-recovery:hover {
                background: #c0392b;
                box-shadow: 0 0 8px rgba(231, 76, 60, 0.5);
            }

            .btn-recovery:active {
                transform: scale(0.98);
            }

            /* Cow Recovery Modal Styles */
            .recovery-modal-cow-list {
                max-height: 400px;
                overflow-y: auto;
                margin: 1rem 0;
            }

            .cow-checkbox-item {
                display: flex;
                align-items: center;
                padding: 0.75rem;
                background: rgba(255, 255, 255, 0.05);
                border: 1px solid #34495e;
                border-radius: 8px;
                margin-bottom: 0.5rem;
                cursor: pointer;
                transition: all 0.2s;
            }

            .cow-checkbox-item:hover {
                background: rgba(255, 255, 255, 0.08);
                border-color: #27ae60;
            }

            .cow-checkbox-item input[type="checkbox"] {
                width: 18px;
                height: 18px;
                margin-right: 0.75rem;
                cursor: pointer;
            }

            .cow-checkbox-info {
                flex: 1;
            }

            .cow-checkbox-info .cow-name {
                font-weight: 600;
                color: #ecf0f1;
                margin-bottom: 0.25rem;
            }

            .cow-checkbox-info .cow-status {
                font-size: 11px;
                color: #95a5a6;
            }

            .cow-checkbox-info .zone-badge {
                display: inline-block;
                padding: 2px 6px;
                border-radius: 3px;
                font-size: 10px;
                margin-left: 0.5rem;
            }

            .zone-badge.zone2 {
                background: #f39c12;
                color: white;
            }

            .zone-badge.zone3 {
                background: #e74c3c;
                color: white;
            }

            /* Create Cow Modal Form Styles */
            .form-input,
            .form-select {
                width: 100%;
                padding: 0.75rem;
                background-color: rgba(255, 255, 255, 0.05);
                border: 1px solid #7f8c8d;
                border-radius: 8px;
                color: #ecf0f1;
                font-size: 14px;
            }

            .form-input:focus,
            .form-select:focus {
                outline: none;
                border-color: #27ae60;
                background-color: rgba(255, 255, 255, 0.08);
                box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.1);
            }

            .form-input::placeholder {
                color: #7f8c8d;
            }

            .form-group {
                margin-bottom: 1.5rem;
            }

            .form-group label {
                display: block;
                color: #ecf0f1;
                margin-bottom: 0.5rem;
                font-weight: 500;
                font-size: 14px;
            }

            .form-actions {
                display: flex;
                gap: 0.5rem;
                margin-top: 2rem;
            }

            .form-actions .btn {
                flex: 1;
            }

            .btn-primary {
                background: #27ae60;
                color: white;
                border: none;
                padding: 0.75rem;
                border-radius: 8px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }

            .btn-primary:hover {
                background: #229954;
                box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
            }

            .btn-secondary {
                background: #34495e;
                color: white;
                border: 1px solid #7f8c8d;
                padding: 0.75rem;
                border-radius: 8px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
            }

            .btn-secondary:hover {
                background: #2c3e50;
            }
        </style>

        <div class="tracking-layout">
            <div class="map-container">
                <div id="trackingMap" class="tracking-map"></div>
            </div>

            <div class="alarm-panel" id="alarmPanel">
                <h3>Real-time Alarms</h3>

                <!-- ESP32 Connection Status -->
                <div id="esp32Status" style="padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 1rem; font-size: 11px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span class="connection-indicator disconnected" id="esp32Indicator"></span>
                        <span id="esp32StatusText">ESP32: Checking...</span>
                    </div>
                </div>

                <div class="alarm-list" id="alarmList">
                    <p class="no-alarms">No active alarms</p>
                </div>
            </div>

            <!-- Compact Virtual Controller Sidebar -->
            <div class="controller-sidebar">
                <h3 style="margin: 0 0 10px 0; font-size: 14px;">Virtual Controller</h3>

                <!-- Cow Selection -->
                <div class="controller-section">
                    <label style="font-size: 11px; display: block; margin-bottom: 3px;">Cow:</label>
                    <select id="virtualCowSelect" style="width: 100%; padding: 4px; font-size: 11px; background: #2c3e50; color: #ecf0f1; border: 1px solid #34495e; border-radius: 3px;">
                        <option value="">-- Select Cow --</option>
                    </select>
                </div>

                <!-- Create Virtual Cow Button -->
                <div class="controller-section">
                    <button id="createVirtualCowBtn" class="btn-create-cow" onclick="openCreateCowModal()">
                        + Create Cow
                    </button>
                </div>

                <!-- Speed Control -->
                <div class="controller-section">
                    <label style="font-size: 11px; display: block; margin-bottom: 3px;">Speed: <span id="virtualSpeed">5</span></label>
                    <input type="range" id="virtualSpeedSlider" min="1" max="20" value="5" style="width: 100%;">
                </div>

                <!-- Direction Buttons -->
                <div class="controller-section">
                    <label style="font-size: 11px; display: block; margin-bottom: 3px;">Direction:</label>
                    <div class="direction-pad-compact">
                        <button class="dir-btn-compact" id="btnUp">‚ñ≤</button>
                        <div style="display: flex; gap: 3px;">
                            <button class="dir-btn-compact" id="btnLeft">‚óÑ</button>
                            <button class="dir-btn-compact" id="btnStop">‚ñ†</button>
                            <button class="dir-btn-compact" id="btnRight">‚ñ∫</button>
                        </div>
                        <button class="dir-btn-compact" id="btnDown">‚ñº</button>
                    </div>
                </div>

                <!-- Joystick -->
                <div class="controller-section">
                    <label style="font-size: 11px; display: block; margin-bottom: 3px;">Joystick:</label>
                    <div id="virtualJoystick" style="width: 100px; height: 100px; margin: 5px auto; background: #34495e; border-radius: 50%; position: relative; border: 2px solid #7f8c8d;">
                        <div id="virtualJoystickKnob" style="width: 30px; height: 30px; background: #3498db; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: grab;"></div>
                    </div>
                </div>

                <!-- Position Display -->
                <div class="controller-section" style="font-size: 10px; color: #95a5a6;">
                    <div>Lat: <span id="virtualLat">0.000000</span></div>
                    <div>Lng: <span id="virtualLng">0.000000</span></div>
                </div>

                <!-- Status -->
                <div class="controller-section" style="font-size: 10px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <span class="connection-indicator disconnected" id="virtualControllerIndicator"></span>
                        <span id="virtualControllerStatus">Select Cow</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="cow-details-modal" id="cowDetailsModal">
            <div class="modal-content">
                <span class="close" onclick="closeCowDetails()">&times;</span>
                <h3 id="cowDetailsTitle">Cow Details</h3>
                <div id="cowDetailsContent">
                    <p><strong>Cow ID:</strong> <span id="cowId"></span></p>
                    <p><strong>Tagging:</strong> <span id="cowTag"></span></p>
                    <p><strong>Speed:</strong> <span id="cowSpeed"></span> km/h</p>
                    <p><strong>Alarm Breaches:</strong></p>
                    <ul id="alarmBreaches">
                        <li>Alarm 1: <span id="alarm1Count">0</span> times</li>
                        <li>Alarm 2: <span id="alarm2Count">0</span> times</li>
                        <li>Alarm 3: <span id="alarm3Count">0</span> times</li>
                    </ul>
                    <div class="modal-actions">
                        <button class="btn btn-primary" id="collaborativeBtn" onclick="generateCollaborativeLink()">
                            Assistive Collaborative
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Virtual Cow Modal -->
        <div class="modal" id="createCowModal">
            <div class="modal-content">
                <span class="close" onclick="closeCreateCowModal()">&times;</span>
                <h2>Create Virtual Cow</h2>
                <p style="color: #95a5a6; font-size: 14px; margin-bottom: 1.5rem;">
                    Create a new virtual cow for testing and development
                </p>

                <form id="createCowForm" onsubmit="handleCreateCow(event)">
                    <div class="form-group">
                        <label for="cowNameInput">Cow Name</label>
                        <input
                            type="text"
                            id="cowNameInput"
                            placeholder="Auto-generated (cow1, cow2, cow3...)"
                            class="form-input"
                        >
                        <small style="color: #95a5a6; font-size: 11px; display: block; margin-top: 0.25rem;">
                            Leave blank for auto-generated name
                        </small>
                    </div>

                    <div class="form-group">
                        <label for="farmSelectModal">Farm Assignment (Optional)</label>
                        <select id="farmSelectModal" class="form-select">
                            <option value="">-- No Farm (0,0 position) --</option>
                            <!-- Farms will be loaded dynamically -->
                        </select>
                        <small style="color: #95a5a6; font-size: 11px; display: block; margin-top: 0.25rem;">
                            Can assign farm later. Cow will spawn at fence center if farm selected.
                        </small>
                    </div>

                    <div class="form-actions">
                        <button type="submit" class="btn btn-primary">
                            Create Cow
                        </button>
                        <button type="button" class="btn btn-secondary" onclick="closeCreateCowModal()">
                            Cancel
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Cow Recovery Modal -->
        <div class="modal" id="cowRecoveryModal">
            <div class="modal-content">
                <span class="close" onclick="closeRecoveryModal()">&times;</span>
                <h2>Cow Recovery</h2>
                <p style="color: #95a5a6; font-size: 14px; margin-bottom: 1rem;">
                    Select cows outside the fence for recovery assistance
                </p>

                <div id="recoverySelectFarm" class="form-group">
                    <label for="recoveryFarmSelect">Select Farm</label>
                    <select id="recoveryFarmSelect" class="form-select" onchange="loadCowsForRecovery()">
                        <option value="">-- Select Farm --</option>
                    </select>
                </div>

                <div class="recovery-modal-cow-list" id="recoveryCowList">
                    <p style="color: #95a5a6; text-align: center; padding: 2rem;">
                        Select a farm to see cows outside the fence
                    </p>
                </div>

                <div class="form-actions">
                    <button type="button" class="btn btn-primary" onclick="startRecovery()" id="startRecoveryBtn" disabled>
                        Start Recovery
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="closeRecoveryModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p><strong>SafeZone</strong> - Developed by Jean Claude & Samuel</p>
            <p>Near East University - 2025-2026 - v1.0.0</p>
        </div>
    </footer>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script defer src="../js/app.js?v=1764488500"></script>
    <script defer src="../js/tracking-new-cows.js"></script>

    <!-- Virtual Controller Script -->
    <script>
        // Virtual Controller Variables
        let selectedVirtualCow = null;
        let virtualCurrentLat = 0;
        let virtualCurrentLng = 0;
        let virtualMovementInterval = null;
        let virtualJoystickInterval = null;
        let virtualHeartbeatInterval = null;
        let virtualSpeedSaveTimeout = null;
        let virtualIsDragging = false;
        const virtualAuthToken = localStorage.getItem('authToken');
        const virtualApiBase = window.location.origin + '/api';

        // Initialize virtual controller when page loads
        window.addEventListener('load', function() {
            // Wait a bit for app.js to fully load
            setTimeout(function() {
                initializeVirtualController();
                setupVirtualCowPositionListener();
            }, 500);
        });

        // Cleanup when page is closed
        window.addEventListener('beforeunload', async function() {
            // Stop heartbeat
            stopVirtualHeartbeat();

            // Disconnect virtual controller if a cow was selected
            if (selectedVirtualCow) {
                try {
                    await fetch(`${virtualApiBase}/dev/controller/disconnect`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${virtualAuthToken}`
                        },
                        keepalive: true // Ensure request completes even as page unloads
                    });
                    console.log('üîå Virtual controller disconnected on page close');
                } catch (error) {
                    console.error('Error disconnecting controller:', error);
                }
            }
        });

        function initializeVirtualController() {
            console.log('üéÆ Initializing Virtual Controller');

            // Check WebSocket status
            setTimeout(() => {
                if (typeof window.wsConnection !== 'undefined' && window.wsConnection) {
                    console.log('‚úÖ WebSocket connection found:', window.wsConnection.readyState);
                    if (window.wsConnection.readyState === 1) {
                        console.log('‚úÖ WebSocket is OPEN and ready');
                    } else {
                        console.warn('‚ö†Ô∏è WebSocket is not open. State:', window.wsConnection.readyState);
                    }
                } else {
                    console.error('‚ùå WebSocket connection not found');
                }

                // Check if currentCows is accessible
                if (typeof window.currentCows !== 'undefined') {
                    console.log('‚úÖ currentCows array accessible, length:', window.currentCows.length);
                    // Clean up any existing duplicates
                    cleanupDuplicateMarkers();
                } else {
                    console.error('‚ùå currentCows array not accessible');
                }
            }, 1000);

            // Load virtual cows and restore last selection
            loadVirtualCows().then(() => {
                // Restore last selection after cows are loaded into dropdown
                restoreLastControllerSelection();
            });

            // Sync cow zones after cows are loaded
            setTimeout(() => {
                syncVirtualCowZones();
            }, 3000);

            // Speed slider
            const speedSlider = document.getElementById('virtualSpeedSlider');
            const speedDisplay = document.getElementById('virtualSpeed');
            if (speedSlider && speedDisplay) {
                speedSlider.addEventListener('input', function() {
                    const newSpeed = this.value;
                    speedDisplay.textContent = newSpeed;
                    console.log('üéöÔ∏è [Speed Slider] User changed speed to:', newSpeed);

                    // Save speed to dbt12 (debounced to avoid too many requests)
                    saveSpeedToDatabase(newSpeed);
                });
            }

            // Direction buttons
            initializeVirtualDirectionButtons();

            // Joystick
            initializeVirtualJoystick();

            // Run duplicate cleanup every 10 seconds
            setInterval(cleanupDuplicateMarkers, 10000);
        }

        // Cleanup duplicate markers
        function cleanupDuplicateMarkers() {
            const currentCows = window.currentCows;
            if (!currentCows) return;

            const seenTokens = new Map();
            const duplicates = [];

            currentCows.forEach((marker, index) => {
                if (marker.cowData && marker.cowData.cow_token) {
                    const token = marker.cowData.cow_token;
                    if (seenTokens.has(token)) {
                        // This is a duplicate
                        duplicates.push({ marker, index });
                    } else {
                        seenTokens.set(token, marker);
                    }
                }
            });

            if (duplicates.length > 0) {
                console.warn(`üßπ Cleaning up ${duplicates.length} duplicate marker(s)`);
                duplicates.reverse().forEach(({ marker, index }) => {
                    if (window.map) {
                        window.map.removeLayer(marker);
                    }
                    currentCows.splice(index, 1);
                });
                window.currentCows = currentCows;
                console.log(`‚úì Cleanup complete. Remaining markers: ${currentCows.length}`);
            }
        }

        // Load virtual cows into the dropdown
        window.loadVirtualCows = async function() {
            try {
                console.log('üîÑ [loadVirtualCows] Called with:');
                console.log('   - window.selectedFarmToken:', window.selectedFarmToken);
                console.log('   - window.selectedFarmName:', window.selectedFarmName);

                const response = await fetch(`${virtualApiBase}/dev/virtual-cows`, {
                    headers: { 'Authorization': `Bearer ${virtualAuthToken}` }
                });
                const data = await response.json();
                let virtualCows = data.virtualCows || [];

                console.log(`üì¶ [loadVirtualCows] Fetched ${virtualCows.length} total cows from API`);
                console.log('   Cows:', virtualCows.map(c => `${c.cow_name}(farm:${c.farm_token})`).join(', '));

                // Filter cows by selected farm
                if (window.selectedFarmToken) {
                    // Specific farm selected: show only cows from this farm + unassigned cows
                    const beforeFilter = virtualCows.length;
                    virtualCows = virtualCows.filter(cow =>
                        cow.farm_token === window.selectedFarmToken ||
                        !cow.farm_token ||
                        cow.farm_token === ''
                    );
                    console.log(`üîç [Specific Farm] Filtered from ${beforeFilter} to ${virtualCows.length} cows for farm token: ${window.selectedFarmToken}`);
                } else if (window.selectedFarmName === 'all') {
                    // "All farms" selected: show ALL cows
                    console.log(`üîç [All Farms] Showing all ${virtualCows.length} virtual cows`);
                } else {
                    // No farm selection yet: show all cows
                    console.log(`üîç [No Selection] No farm selected yet, showing all ${virtualCows.length} virtual cows`);
                }

                const select = document.getElementById('virtualCowSelect');
                select.innerHTML = '<option value="">-- Select Cow --</option>';

                console.log(`üìù [loadVirtualCows] Populating dropdown with ${virtualCows.length} cows`);
                virtualCows.forEach(cow => {
                    const option = document.createElement('option');
                    option.value = cow.cow_token;
                    option.textContent = `${cow.cow_nickname} (${cow.collar_id})`;
                    option.dataset.lat = cow.gps_latitude || 0;
                    option.dataset.lng = cow.gps_longitude || 0;
                    select.appendChild(option);
                    console.log(`   ‚úì Added: ${cow.cow_nickname} (farm: ${cow.farm_token || 'unassigned'})`);
                });

                console.log(`‚úÖ [loadVirtualCows] Dropdown updated successfully with ${virtualCows.length} options`);

                // Cow selection change
                select.addEventListener('change', function() {
                    const selectedOption = this.options[this.selectedIndex];
                    if (selectedOption.value) {
                        selectedVirtualCow = selectedOption.value;

                        // Get the actual current position from the map marker instead of stale dropdown data
                        const cowMarker = window.currentCows?.find(marker =>
                            marker.cowData && marker.cowData.cow_token === selectedOption.value
                        );

                        if (cowMarker) {
                            // Use the marker's current position (most up-to-date)
                            const currentPos = cowMarker.getLatLng();
                            virtualCurrentLat = currentPos.lat;
                            virtualCurrentLng = currentPos.lng;
                        } else {
                            // Fallback to dropdown data if marker not found
                            virtualCurrentLat = parseFloat(selectedOption.dataset.lat);
                            virtualCurrentLng = parseFloat(selectedOption.dataset.lng);
                        }

                        document.getElementById('virtualLat').textContent = virtualCurrentLat.toFixed(6);
                        document.getElementById('virtualLng').textContent = virtualCurrentLng.toFixed(6);

                        const indicator = document.getElementById('virtualControllerIndicator');
                        const status = document.getElementById('virtualControllerStatus');
                        indicator.classList.remove('disconnected');
                        indicator.classList.add('connected');
                        status.textContent = selectedOption.textContent;

                        // Notify server that this cow is now being controlled
                        notifyServerControllerSelect(selectedVirtualCow, window.selectedFarmToken);

                        // Start heartbeat to keep server informed that page19 is active
                        startVirtualHeartbeat(window.selectedFarmToken);
                    } else {
                        selectedVirtualCow = null;
                        document.getElementById('virtualControllerIndicator').classList.remove('connected');
                        document.getElementById('virtualControllerIndicator').classList.add('disconnected');
                        document.getElementById('virtualControllerStatus').textContent = 'Select Cow';

                        // Stop heartbeat when cow is deselected
                        stopVirtualHeartbeat();
                    }
                });
            } catch (error) {
                console.error('Error loading virtual cows:', error);
            }
        };

        // Restore last selected cow and farm from dbt12
        async function restoreLastControllerSelection() {
            try {
                console.log('üîÑ Restoring last controller selection from dbt12...');

                const response = await fetch(`${virtualApiBase}/dev/controller/current`, {
                    headers: { 'Authorization': `Bearer ${virtualAuthToken}` }
                });

                if (!response.ok) {
                    console.log('‚ÑπÔ∏è No previous controller selection found');
                    return;
                }

                const data = await response.json();
                const selection = data.selection;

                if (!selection || !selection.selected_cow_token) {
                    console.log('‚ÑπÔ∏è No cow was previously selected');
                    return;
                }

                console.log('‚úÖ Found previous selection:', {
                    cow: selection.cow_nickname,
                    farm: selection.farm_name,
                    lastSpeed: selection.last_speed_scale
                });

                // Restore farm selection if needed
                if (selection.selected_farm_token && selection.selected_farm_token !== window.selectedFarmToken) {
                    const farmSelect = document.getElementById('farmSelect');
                    if (farmSelect) {
                        farmSelect.value = selection.selected_farm_token;
                        window.selectedFarmToken = selection.selected_farm_token;
                        console.log('‚úÖ Farm restored:', selection.farm_name);
                    }
                }

                // Restore speed scale FIRST (before cow selection)
                if (selection.last_speed_scale !== null && selection.last_speed_scale !== undefined) {
                    const speedSlider = document.getElementById('virtualSpeedSlider');
                    const speedDisplay = document.getElementById('virtualSpeed');
                    if (speedSlider && speedDisplay) {
                        speedSlider.value = selection.last_speed_scale;
                        speedDisplay.textContent = selection.last_speed_scale;
                        console.log('‚úÖ Speed scale restored from database:', selection.last_speed_scale);
                    } else {
                        console.warn('‚ö†Ô∏è Speed slider elements not found');
                    }
                } else {
                    console.log('‚ÑπÔ∏è No speed scale to restore (value:', selection.last_speed_scale, ')');
                }

                // Restore cow selection (after speed is set)
                const cowSelect = document.getElementById('virtualCowSelect');
                if (cowSelect) {
                    console.log('üîç Looking for cow in dropdown:', selection.selected_cow_token);
                    console.log('üîç Dropdown has', cowSelect.options.length, 'options');

                    const cowOption = Array.from(cowSelect.options).find(opt => opt.value === selection.selected_cow_token);
                    if (cowOption) {
                        cowSelect.value = selection.selected_cow_token;
                        // Trigger the change event to activate the controller
                        cowSelect.dispatchEvent(new Event('change'));
                        console.log('‚úÖ Cow restored and controller activated:', selection.cow_nickname);
                    } else {
                        console.warn('‚ö†Ô∏è Previously selected cow not found in dropdown');
                        console.warn('   Cow token:', selection.selected_cow_token);
                        console.warn('   Available options:', Array.from(cowSelect.options).map(opt => opt.value));
                    }
                } else {
                    console.error('‚ùå virtualCowSelect element not found');
                }

            } catch (error) {
                console.error('‚ùå Error restoring controller selection:', error);
            }
        }

        // Notify server that a cow is now being controlled
        async function notifyServerControllerSelect(cowToken, farmToken) {
            try {
                const response = await fetch(`${virtualApiBase}/dev/controller/select`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${virtualAuthToken}`
                    },
                    body: JSON.stringify({
                        cowToken: cowToken,
                        farmToken: farmToken
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ Server notified: Virtual controller connected');
                } else {
                    console.warn('‚ö†Ô∏è Failed to notify server:', response.status);
                }
            } catch (error) {
                console.error('‚ùå Error notifying server:', error);
            }
        }

        // Start heartbeat to keep connection alive
        function startVirtualHeartbeat(farmToken) {
            // Clear any existing heartbeat
            stopVirtualHeartbeat();

            console.log('üíì Starting heartbeat for', selectedVirtualCow);

            // Send immediate heartbeat
            sendVirtualHeartbeat(farmToken);

            // Send heartbeat every 15 seconds
            virtualHeartbeatInterval = setInterval(() => {
                sendVirtualHeartbeat(farmToken);
            }, 15000);
        }

        // Send a single heartbeat
        async function sendVirtualHeartbeat(farmToken) {
            if (!selectedVirtualCow) {
                stopVirtualHeartbeat();
                return;
            }

            try {
                const response = await fetch(`${virtualApiBase}/dev/controller/heartbeat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${virtualAuthToken}`
                    },
                    body: JSON.stringify({
                        cowToken: selectedVirtualCow,
                        farmToken: farmToken
                    })
                });

                if (response.ok) {
                    console.log('üíì Heartbeat sent');
                } else {
                    console.warn('‚ö†Ô∏è Heartbeat failed:', response.status);
                }
            } catch (error) {
                console.error('‚ùå Heartbeat error:', error);
            }
        }

        // Stop heartbeat
        function stopVirtualHeartbeat() {
            if (virtualHeartbeatInterval) {
                clearInterval(virtualHeartbeatInterval);
                virtualHeartbeatInterval = null;
                console.log('üíî Heartbeat stopped');
            }
        }

        // Save speed to dbt12 (debounced)
        function saveSpeedToDatabase(speed) {
            // Clear previous timeout to debounce
            if (virtualSpeedSaveTimeout) {
                clearTimeout(virtualSpeedSaveTimeout);
                console.log('üîÑ [Speed Save] Debouncing... (clearing previous timeout)');
            }

            console.log(`üîÑ [Speed Save] Will save speed ${speed} in 500ms (debounced)`);

            // Wait 500ms after user stops sliding before saving
            virtualSpeedSaveTimeout = setTimeout(async () => {
                if (!selectedVirtualCow) {
                    console.warn('‚ö†Ô∏è [Speed Save] No cow selected, cannot save speed');
                    return;
                }

                const speedInt = parseInt(speed);
                console.log('üíæ [Speed Save] NOW SAVING to database:', {
                    cow: selectedVirtualCow,
                    speedString: speed,
                    speedInt: speedInt,
                    lat: virtualCurrentLat,
                    lng: virtualCurrentLng
                });

                try {
                    const requestBody = {
                        latitude: virtualCurrentLat,
                        longitude: virtualCurrentLng,
                        speed: speedInt,
                        zone: null // Don't update zone, just save speed
                    };
                    console.log('üì§ [Speed Save] Request body:', JSON.stringify(requestBody));

                    const response = await fetch(`${virtualApiBase}/dev/virtual-cows/${selectedVirtualCow}/position`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${virtualAuthToken}`
                        },
                        body: JSON.stringify(requestBody)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log(`‚úÖ [Speed Save] SUCCESS! Speed ${speedInt} saved to dbt12 | Response:`, data);
                    } else {
                        console.warn(`‚ö†Ô∏è [Speed Save] FAILED with status ${response.status}`);
                        const errorText = await response.text();
                        console.warn('   Error:', errorText);
                    }
                } catch (error) {
                    console.error('‚ùå [Speed Save] Error:', error);
                }
            }, 500);
        }

        // Initialize direction buttons with long-press
        function initializeVirtualDirectionButtons() {
            const buttons = {
                'btnUp': 'north',
                'btnDown': 'south',
                'btnLeft': 'west',
                'btnRight': 'east',
                'btnStop': 'stop'
            };

            Object.keys(buttons).forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    const direction = buttons[id];

                    // Mouse events
                    btn.addEventListener('mousedown', () => startVirtualContinuousMovement(direction));
                    btn.addEventListener('mouseup', stopVirtualContinuousMovement);
                    btn.addEventListener('mouseleave', stopVirtualContinuousMovement);

                    // Touch events
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        startVirtualContinuousMovement(direction);
                    });
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        stopVirtualContinuousMovement();
                    });
                }
            });
        }

        function startVirtualContinuousMovement(direction) {
            if (!selectedVirtualCow) {
                alert('Please select a virtual cow first!');
                return;
            }

            if (direction === 'stop') {
                stopVirtualContinuousMovement();
                moveVirtualCowToFence();
                return;
            }

            const speed = parseFloat(document.getElementById('virtualSpeedSlider').value);
            if (speed === 0) {
                alert('Please set a speed first!');
                return;
            }

            // Move immediately
            moveVirtualDirection(direction, speed);

            // Continue moving every 100ms
            if (virtualMovementInterval) clearInterval(virtualMovementInterval);
            virtualMovementInterval = setInterval(() => {
                moveVirtualDirection(direction, speed);
            }, 100);
        }

        // Move virtual cow to the center of the fence
        function moveVirtualCowToFence() {
            if (!selectedVirtualCow) {
                console.error('No virtual cow selected');
                return;
            }

            // Get the selected cow's data to find its farm
            const cowMarker = window.currentCows?.find(marker =>
                marker.cowData && marker.cowData.cow_token === selectedVirtualCow
            );

            if (!cowMarker || !cowMarker.cowData) {
                alert('Cannot find cow data. Please select a cow again.');
                console.error('No cow marker found for selected cow:', selectedVirtualCow);
                return;
            }

            const cowFarmToken = cowMarker.cowData.farm_token;
            console.log(`üìç Selected cow ${cowMarker.cowData.cow_name} belongs to farm token: ${cowFarmToken}`);

            // Check if fences exist
            if (!window.currentFences || window.currentFences.length === 0) {
                alert('No fence available. Please create a fence first.');
                console.error('No fence found in window.currentFences');
                return;
            }

            // Find the fence that belongs to the cow's farm
            let fencePolygon = null;

            if (cowFarmToken) {
                // Try to find the fence matching the cow's farm
                fencePolygon = window.currentFences.find(fence => fence.farmToken === cowFarmToken);

                if (!fencePolygon) {
                    console.warn(`No fence found for cow's farm token ${cowFarmToken}, using first available fence`);
                    fencePolygon = window.currentFences[0];
                }
            } else {
                // Cow has no farm assigned, use first fence
                console.log('Cow has no farm assigned, using first available fence');
                fencePolygon = window.currentFences[0];
            }

            if (!fencePolygon || !fencePolygon.getLatLngs) {
                alert('Invalid fence data. Please reload the page.');
                console.error('Invalid fence polygon');
                return;
            }

            // Get fence coordinates
            const latLngs = fencePolygon.getLatLngs()[0];

            if (!latLngs || latLngs.length === 0) {
                alert('Fence has no coordinates.');
                console.error('Fence has no coordinates');
                return;
            }

            // Calculate the centroid (center point) of the polygon
            let sumLat = 0;
            let sumLng = 0;

            latLngs.forEach(point => {
                sumLat += point.lat;
                sumLng += point.lng;
            });

            const centerLat = sumLat / latLngs.length;
            const centerLng = sumLng / latLngs.length;

            console.log(`üìç Moving virtual cow ${cowMarker.cowData.cow_name} to fence center: (${centerLat.toFixed(6)}, ${centerLng.toFixed(6)})`);

            // Update the virtual cow position to the center of the fence
            virtualCurrentLat = centerLat;
            virtualCurrentLng = centerLng;

            // Update the position on the server and map
            updateVirtualPosition();
        }

        function stopVirtualContinuousMovement() {
            if (virtualMovementInterval) {
                clearInterval(virtualMovementInterval);
                virtualMovementInterval = null;
            }
        }

        function moveVirtualDirection(direction, speed) {
            const moveDistance = (speed / 3600) * 0.001;

            switch(direction) {
                case 'north':
                    virtualCurrentLat += moveDistance;
                    break;
                case 'south':
                    virtualCurrentLat -= moveDistance;
                    break;
                case 'east':
                    virtualCurrentLng += moveDistance;
                    break;
                case 'west':
                    virtualCurrentLng -= moveDistance;
                    break;
            }

            updateVirtualPosition();
        }

        // Initialize joystick
        function initializeVirtualJoystick() {
            const joystickOuter = document.getElementById('virtualJoystick');
            const joystickKnob = document.getElementById('virtualJoystickKnob');

            if (!joystickOuter || !joystickKnob) return;

            const maxDistance = (joystickOuter.offsetWidth / 2) - (joystickKnob.offsetWidth / 2);

            function handleJoystickMove(clientX, clientY) {
                const rect = joystickOuter.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = clientX - centerX;
                let deltaY = clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }

                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                const normalizedDistance = Math.min(distance / maxDistance, 1);
                const angle = Math.atan2(-deltaY, deltaX);

                return { angle, distance: normalizedDistance };
            }

            function startJoystickMovement(clientX, clientY) {
                if (!selectedVirtualCow) {
                    alert('Please select a virtual cow first!');
                    virtualIsDragging = false;
                    return;
                }

                const speed = parseFloat(document.getElementById('virtualSpeedSlider').value);
                if (speed === 0) {
                    alert('Please set a speed first!');
                    virtualIsDragging = false;
                    return;
                }

                const updateMovement = () => {
                    if (!virtualIsDragging) return;

                    const { angle, distance } = handleJoystickMove(clientX, clientY);

                    if (distance > 0.1) {
                        const moveDistance = (speed / 3600) * 0.001 * distance;
                        const latChange = Math.sin(angle) * moveDistance;
                        const lngChange = Math.cos(angle) * moveDistance;

                        virtualCurrentLat += latChange;
                        virtualCurrentLng += lngChange;

                        updateVirtualPosition();
                    }
                };

                updateMovement();

                if (virtualJoystickInterval) clearInterval(virtualJoystickInterval);
                virtualJoystickInterval = setInterval(updateMovement, 100);
            }

            function stopJoystickMovement() {
                virtualIsDragging = false;
                if (virtualJoystickInterval) {
                    clearInterval(virtualJoystickInterval);
                    virtualJoystickInterval = null;
                }
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }

            // Mouse events
            joystickKnob.addEventListener('mousedown', (e) => {
                e.preventDefault();
                virtualIsDragging = true;
            });

            document.addEventListener('mousemove', (e) => {
                if (virtualIsDragging) {
                    startJoystickMovement(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mouseup', () => {
                if (virtualIsDragging) {
                    stopJoystickMovement();
                }
            });

            // Touch events
            joystickKnob.addEventListener('touchstart', (e) => {
                e.preventDefault();
                virtualIsDragging = true;
            });

            document.addEventListener('touchmove', (e) => {
                if (virtualIsDragging && e.touches.length > 0) {
                    const touch = e.touches[0];
                    startJoystickMovement(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchend', () => {
                if (virtualIsDragging) {
                    stopJoystickMovement();
                }
            });
        }

        // Update position to server
        async function updateVirtualPosition() {
            document.getElementById('virtualLat').textContent = virtualCurrentLat.toFixed(6);
            document.getElementById('virtualLng').textContent = virtualCurrentLng.toFixed(6);

            if (selectedVirtualCow) {
                // Optimistically update the map marker immediately
                updateMapMarkerPosition(selectedVirtualCow, virtualCurrentLat, virtualCurrentLng);

                try {
                    // Get the cow's farm token from the cow marker
                    const cowMarker = window.currentCows?.find(marker =>
                        marker.cowData && marker.cowData.cow_token === selectedVirtualCow
                    );
                    const cowFarmToken = cowMarker?.cowData?.farm_token;

                    // Calculate the zone for this position (check against cow's OWN farm's fence)
                    const cowPosition = L.latLng(virtualCurrentLat, virtualCurrentLng);
                    const zone = determineCowZoneFromPosition(cowPosition, cowFarmToken);

                    const speed = parseInt(document.getElementById('virtualSpeedSlider').value);
                    const response = await fetch(`${virtualApiBase}/dev/virtual-cows/${selectedVirtualCow}/position`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${virtualAuthToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            latitude: virtualCurrentLat,
                            longitude: virtualCurrentLng,
                            speed: speed,
                            zone: zone
                        })
                    });

                    if (response.ok) {
                        // Flash the status indicator to show update was sent
                        const indicator = document.getElementById('virtualControllerIndicator');
                        indicator.style.boxShadow = '0 0 15px #27ae60';
                        setTimeout(() => {
                            indicator.style.boxShadow = '0 0 8px #27ae60';
                        }, 100);
                    }
                } catch (error) {
                    console.error('Error updating virtual position:', error);
                }
            }
        }

        // Optimistically update the map marker position
        let debugCount = 0;
        function updateMapMarkerPosition(cowToken, lat, lng) {
            // Access currentCows from window (defined in app.js)
            const currentCows = window.currentCows;

            if (!currentCows) {
                console.error('‚ùå currentCows array not found in window');
                return;
            }

            // Debug: Check for duplicate markers
            const matchingMarkers = currentCows.filter(c => c.cowData && c.cowData.cow_token === cowToken);
            if (matchingMarkers.length > 1) {
                console.error(`‚ö†Ô∏è DUPLICATE MARKERS DETECTED! Found ${matchingMarkers.length} markers for token:`, cowToken);
                // Remove duplicates - keep only the first one
                for (let i = 1; i < matchingMarkers.length; i++) {
                    const duplicateMarker = matchingMarkers[i];
                    if (window.map) {
                        window.map.removeLayer(duplicateMarker);
                    }
                    const index = currentCows.indexOf(duplicateMarker);
                    if (index > -1) {
                        currentCows.splice(index, 1);
                    }
                }
                window.currentCows = currentCows;
                console.log(`‚úì Removed ${matchingMarkers.length - 1} duplicate marker(s)`);
            }

            // Debug only first 3 times to avoid spam
            if (debugCount < 3) {
                console.log('üîç Searching for cow marker:', cowToken);
                console.log('üìä Total markers in currentCows:', currentCows.length);
                debugCount++;
            }

            const cowMarker = currentCows.find(c => c.cowData && c.cowData.cow_token === cowToken);

            if (cowMarker) {
                const oldLat = cowMarker.getLatLng().lat;
                const oldLng = cowMarker.getLatLng().lng;

                // Move the marker to the new position
                cowMarker.setLatLng([lat, lng]);

                if (cowMarker.cowData) {
                    cowMarker.cowData.gps_latitude = lat;
                    cowMarker.cowData.gps_longitude = lng;
                    cowMarker.cowData.real_time_coordinate = `${lat},${lng}`;
                }

                if (debugCount <= 3) {
                    console.log(`‚úÖ Marker moved to: (${lat.toFixed(6)}, ${lng.toFixed(6)})`);
                }
            } else {
                console.error('‚ùå Cow marker not found for token:', cowToken);
                console.error('Available tokens:', currentCows.map(c => c.cowData?.cow_token).filter(Boolean));
            }
        }

        // Synchronize virtual cow zones with database on page load
        async function syncVirtualCowZones() {
            console.log('\nüîÑ [Zone Sync] Starting zone synchronization...');

            const currentCows = window.currentCows;
            const currentFences = window.currentFences;

            if (!currentCows) {
                console.warn('‚ö†Ô∏è [Zone Sync] currentCows not available yet');
                return;
            }

            if (!currentFences || currentFences.length === 0) {
                console.warn('‚ö†Ô∏è [Zone Sync] No fences available - retrying in 2 seconds...');
                setTimeout(syncVirtualCowZones, 2000);
                return;
            }

            const selectedFence = currentFences.find(f => f.selected);
            if (!selectedFence) {
                console.warn('‚ö†Ô∏è [Zone Sync] No fence selected - cannot calculate zones');
                return;
            }

            console.log(`‚úì [Zone Sync] Fence available, checking ${currentCows.length} cows`);

            let syncedCount = 0;
            let virtualCount = 0;

            for (const cowMarker of currentCows) {
                if (!cowMarker.cowData) continue;

                const cowData = cowMarker.cowData;
                const isVirtual = cowData.isVirtual === true || cowData.cow_type === 'virtual';

                console.log(`üîç [Zone Sync] ${cowData.cow_name}: isVirtual=${cowData.isVirtual}, cow_type=${cowData.cow_type}, combined=${isVirtual}`);

                if (!isVirtual) continue;

                virtualCount++;
                const cowPosition = cowMarker.getLatLng();
                const cowFarmToken = cowData.farm_token;

                // Calculate actual zone from GPS position (check against cow's OWN farm's fence)
                const actualZone = determineCowZoneFromPosition(cowPosition, cowFarmToken);
                const databaseZone = cowData.state_fence;

                console.log(`üîç [Zone Sync] ${cowData.cow_name}: DB zone=${databaseZone}, Calculated zone=${actualZone}, Farm=${cowFarmToken || 'unassigned'}, Position=(${cowPosition.lat.toFixed(6)}, ${cowPosition.lng.toFixed(6)})`);

                // If zones don't match, sync to database
                if (actualZone !== databaseZone) {
                    console.log(`üîÑ [Zone Sync] ${cowData.cow_name}: Mismatch detected - syncing...`);

                    try {
                        // Read current speed from slider (don't hardcode to 0!)
                        const currentSpeed = parseInt(document.getElementById('virtualSpeedSlider')?.value || 0);
                        console.log(`üîÑ [Zone Sync] Reading speed from slider: ${currentSpeed} (for ${cowData.cow_name})`);

                        const response = await fetch(`${virtualApiBase}/dev/virtual-cows/${cowData.cow_token}/position`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${virtualAuthToken}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                latitude: cowPosition.lat,
                                longitude: cowPosition.lng,
                                zone: actualZone,
                                speed: currentSpeed
                            })
                        });

                        if (response.ok) {
                            syncedCount++;
                            console.log(`‚úÖ [Zone Sync] ${cowData.cow_name} synced to ${actualZone}`);
                        } else {
                            console.error(`‚ùå [Zone Sync] Server returned ${response.status}`);
                        }
                    } catch (error) {
                        console.error(`‚ùå [Zone Sync] Failed to sync ${cowData.cow_name}:`, error);
                    }
                } else {
                    console.log(`‚úì [Zone Sync] ${cowData.cow_name}: Already in sync (${actualZone})`);
                }
            }

            console.log(`‚úÖ [Zone Sync] Complete. Virtual cows: ${virtualCount}, Synced: ${syncedCount}`);
        }

        // Zone Calculation Functions
        function determineCowZoneFromPosition(cowPosition, cowFarmToken = null) {
            // Find the fence that belongs to this cow's farm
            if (!window.currentFences || window.currentFences.length === 0) {
                return 'zone1'; // Default to safe zone
            }

            let fencePolygon = null;

            if (cowFarmToken) {
                // Try to find fence matching cow's farm
                fencePolygon = window.currentFences.find(fence => fence.farmToken === cowFarmToken);

                if (!fencePolygon) {
                    console.warn(`‚ö†Ô∏è [determineCowZoneFromPosition] No fence found for cow's farm ${cowFarmToken}, using first fence as fallback`);
                    fencePolygon = window.currentFences[0];
                }
            } else {
                // No farm token provided, use selected fence or first fence
                fencePolygon = window.currentFences.find(f => f.selected) || window.currentFences[0];
            }

            if (!fencePolygon || !fencePolygon.getLatLngs) {
                return 'zone1'; // Default to safe zone
            }

            // Check if cow is inside fence (zone1)
            if (isPointInPolygon(cowPosition, fencePolygon)) {
                return 'zone1';
            }

            // Check distance from fence boundary
            const distanceFromFence = getDistanceFromFenceBoundary(cowPosition, fencePolygon);

            // Zone2: 0-50 meters outside fence (line1 to line2)
            // Zone3: more than 50 meters outside fence (beyond line2)
            if (distanceFromFence <= 50) {
                return 'zone2';
            } else {
                return 'zone3';
            }
        }

        // Check if point is inside polygon
        function isPointInPolygon(point, polygon) {
            const latLngs = polygon.getLatLngs()[0];
            let inside = false;
            const x = point.lat, y = point.lng;

            for (let i = 0, j = latLngs.length - 1; i < latLngs.length; j = i++) {
                const xi = latLngs[i].lat, yi = latLngs[i].lng;
                const xj = latLngs[j].lat, yj = latLngs[j].lng;

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }

            return inside;
        }

        // Get minimum distance from point to polygon boundary
        function getDistanceFromFenceBoundary(point, polygon) {
            const latLngs = polygon.getLatLngs()[0];
            let minDistance = Infinity;

            for (let i = 0; i < latLngs.length; i++) {
                const p1 = latLngs[i];
                const p2 = latLngs[(i + 1) % latLngs.length];

                const distance = getDistanceToLineSegment(point, p1, p2);
                minDistance = Math.min(minDistance, distance);
            }

            return minDistance;
        }

        // Calculate distance from point to line segment using Haversine (accurate)
        function getDistanceToLineSegment(point, lineStart, lineEnd) {
            const A = point.lat - lineStart.lat;
            const B = point.lng - lineStart.lng;
            const C = lineEnd.lat - lineStart.lat;
            const D = lineEnd.lng - lineStart.lng; // Fixed bug: was lineEnd.lng - lineEnd.lng

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let closestLat, closestLng;

            if (param < 0) {
                // Closest point is lineStart
                closestLat = lineStart.lat;
                closestLng = lineStart.lng;
            } else if (param > 1) {
                // Closest point is lineEnd
                closestLat = lineEnd.lat;
                closestLng = lineEnd.lng;
            } else {
                // Closest point is on the line segment
                closestLat = lineStart.lat + param * C;
                closestLng = lineStart.lng + param * D;
            }

            // Use Haversine formula for accurate distance calculation
            return haversineDistance(point.lat, point.lng, closestLat, closestLng);
        }

        // Setup listener for WebSocket updates
        function setupVirtualCowPositionListener() {
            // Override the updateVirtualCowPosition function to also update the controller display
            if (typeof window.updateVirtualCowPosition === 'function') {
                const originalUpdate = window.updateVirtualCowPosition;
                window.updateVirtualCowPosition = function(data) {
                    console.log('üì° WebSocket: Virtual cow position update received', data);

                    // Call the original function to update the map
                    originalUpdate(data);

                    // Update the controller display if it's the selected cow
                    if (selectedVirtualCow && data.cow_token === selectedVirtualCow) {
                        virtualCurrentLat = data.latitude;
                        virtualCurrentLng = data.longitude;
                        document.getElementById('virtualLat').textContent = virtualCurrentLat.toFixed(6);
                        document.getElementById('virtualLng').textContent = virtualCurrentLng.toFixed(6);
                        console.log('‚úì Virtual controller synced with WebSocket update');
                    }
                };
                console.log('‚úì Virtual controller WebSocket listener installed');
            } else {
                console.warn('‚ö† updateVirtualCowPosition function not found - retrying in 1s');
                setTimeout(setupVirtualCowPositionListener, 1000);
            }
        }
    </script>

    <!-- Alarm System Audio -->
    <audio id="alarm1Audio" preload="auto" style="display:none;">
        <source src="../audio/cow.mp3" type="audio/mpeg">
    </audio>

    <!-- Audio Enable Button -->
    <div id="audioEnablePrompt" style="position: fixed; top: 80px; right: 10px; z-index: 1001; background: #f59e0b; color: #000; padding: 10px 15px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.2); display: none;">
        <div style="font-weight: bold; margin-bottom: 5px;">üîä Alarm Audio Disabled</div>
        <div style="font-size: 12px; margin-bottom: 8px;">Click to enable alarm sounds</div>
        <button id="enableAudioBtn" style="background: #000; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; width: 100%;">
            Enable Audio
        </button>
    </div>

    <!-- Alarm System Script -->
    <script>
        // Alarm System State (from quick.txt instructions)
        const alarmSystemState = {
            alarm1Active: false,
            alarm1Timer: null,
            alarm1Duration: 20000, // 20 seconds
            alarm1StartTime: null,
            cowAlarmTimers: new Map(), // Track time each cow spends in zone2
            cowAlarmZones: new Map(), // Track which zone each cow is in
            alarmEmailSent: new Map(), // Track if email was sent for each cow
            cowsTriggeredReset: new Set(), // Track which cows have already triggered alarm reset in current cycle
            alarmAudioElement: null,
            audioEnabled: false
        };

        // Initialize alarm system
        setTimeout(() => {
            alarmSystemState.alarmAudioElement = document.getElementById('alarm1Audio');
            console.log('üîä Alarm system initialized on page19');

            // Setup audio enable button
            const enableBtn = document.getElementById('enableAudioBtn');
            const audioPrompt = document.getElementById('audioEnablePrompt');

            enableBtn.addEventListener('click', async () => {
                try {
                    // Try to play and immediately pause to unlock audio
                    await alarmSystemState.alarmAudioElement.play();
                    alarmSystemState.alarmAudioElement.pause();
                    alarmSystemState.alarmAudioElement.currentTime = 0;

                    alarmSystemState.audioEnabled = true;
                    audioPrompt.style.display = 'none';
                    console.log('‚úÖ Alarm audio enabled successfully');
                } catch (error) {
                    console.error('Failed to enable audio:', error);
                    alert('Failed to enable audio. Please try again.');
                }
            });

            // Show the prompt initially
            audioPrompt.style.display = 'block';

            startCowAlarmMonitoring();
        }, 2000);

        // Start monitoring system
        function startCowAlarmMonitoring() {
            setInterval(checkAllCowAlarms, 1000); // Check every second
            setInterval(updateESP32Status, 2000); // Update ESP32 status every 2 seconds
        }

        // Update ESP32 connection status
        function updateESP32Status() {
            const indicator = document.getElementById('esp32Indicator');
            const statusText = document.getElementById('esp32StatusText');

            if (!indicator || !statusText) return;

            // Check WebSocket connection
            if (window.wsConnection && window.wsConnection.readyState === 1) {
                indicator.classList.remove('disconnected');
                indicator.classList.add('connected');
                statusText.textContent = 'ESP32: Connected';
                statusText.style.color = '#10b981';
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
                statusText.textContent = 'ESP32: Disconnected';
                statusText.style.color = '#ef4444';
            }
        }

        // Main alarm checking function
        function checkAllCowAlarms() {
            if (!window.currentCows || !window.currentFences) {
                return;
            }

            if (window.currentFences.length === 0) {
                return;
            }

            const currentTime = Date.now();
            let cowsInZone2 = [];
            let cowsInZone3 = [];

            // Check each cow's position
            window.currentCows.forEach(cowMarker => {
                if (!cowMarker.cowData) return;

                const cowToken = cowMarker.cowData.cow_token || cowMarker.cowData.collar_id;
                const cowPosition = cowMarker.getLatLng();
                const cowFarmToken = cowMarker.cowData.farm_token;

                // Determine which zone the cow is in (check against its OWN farm's fence)
                const zone = getCowZone(cowPosition, cowFarmToken);
                const previousZone = alarmSystemState.cowAlarmZones.get(cowToken);

                console.log(`üîç [ZONE CHECK] ${cowMarker.cowData.cow_nickname || cowToken}: zone=${zone}, farm=${cowFarmToken || 'unassigned'}, pos=(${cowPosition.lat.toFixed(6)}, ${cowPosition.lng.toFixed(6)})`);

                // Update cow zone
                alarmSystemState.cowAlarmZones.set(cowToken, zone);

                // Handle zone2 (between line1 and line2)
                if (zone === 'zone2') {
                    cowsInZone2.push(cowToken);

                    // If cow just entered zone2, start timer
                    if (previousZone !== 'zone2') {
                        alarmSystemState.cowAlarmTimers.set(cowToken, {
                            enteredAt: currentTime,
                            emailSentAt10: false,
                            emailSentAt25: false,
                            alarm1Triggered: false  // Track if alarm1 was already triggered for this cow
                        });
                        const cowName = cowMarker.cowData.cow_nickname || cowMarker.cowData.cow_name || cowToken;
                        console.log(`üö® [COW OUTSIDE] ${cowName} ENTERED ZONE2 (WARNING ZONE) - Token: ${cowToken}`);
                    }

                    const timer = alarmSystemState.cowAlarmTimers.get(cowToken);
                    const timeInZone2 = (currentTime - timer.enteredAt) / 1000; // seconds

                    console.log(`‚è±Ô∏è [COW ${cowMarker.cowData.cow_nickname || cowToken}] Time in zone2: ${timeInZone2.toFixed(1)}s`);

                    // Trigger alarm1 after 10 seconds in zone2 (only once per cow entry)
                    if (timeInZone2 >= 10 && !alarmSystemState.alarm1Active && !timer.alarm1Triggered) {
                        console.log(`üö®üö®üö® [ALARM1 TRIGGER] Cow ${cowMarker.cowData.cow_nickname || cowToken} in zone2 for ${timeInZone2.toFixed(1)}s`);
                        triggerAlarm1(cowMarker.cowData);
                        timer.alarm1Triggered = true; // Mark that we've triggered alarm for this cow
                        // Mark this cow as the initial trigger (so it doesn't reset its own alarm)
                        alarmSystemState.cowsTriggeredReset.add(cowToken);
                    }

                    // Reset alarm timer if another cow triggers while alarm is active (only once per cow)
                    if (timeInZone2 >= 10 && alarmSystemState.alarm1Active && !alarmSystemState.cowsTriggeredReset.has(cowToken)) {
                        console.log(`üîÑ [ALARM1 RESET] New cow triggering alarm reset: ${cowMarker.cowData.cow_nickname || cowToken}`);
                        resetAlarmTimer(cowMarker.cowData);
                        // Mark this cow as having triggered a reset
                        alarmSystemState.cowsTriggeredReset.add(cowToken);
                    }

                    // Send email after 25 seconds in zone2
                    if (timeInZone2 >= 25 && !timer.emailSentAt25) {
                        console.log(`üìß [ALARM2 TRIGGER] Sending zone2 email for ${cowMarker.cowData.cow_nickname || cowToken} (${timeInZone2.toFixed(1)}s in zone2)`);
                        sendAlarmZone2Email(cowMarker.cowData);
                        timer.emailSentAt25 = true;
                    }

                } else if (zone === 'zone3') {
                    cowsInZone3.push(cowToken);

                    // Cow breached line2 - create timer if doesn't exist
                    if (!alarmSystemState.cowAlarmTimers.has(cowToken)) {
                        alarmSystemState.cowAlarmTimers.set(cowToken, {
                            enteredAt: currentTime,
                            emailSentAt10: false,
                            emailSentAt25: false,
                            alarm1Triggered: false
                        });
                        const cowName = cowMarker.cowData.cow_nickname || cowMarker.cowData.cow_name || cowToken;
                        console.log(`üö®üö®üö® [COW OUTSIDE] ${cowName} ENTERED ZONE3 (DANGER ZONE) - Token: ${cowToken}`);
                    }

                    // Send email immediately if not already sent
                    if (!alarmSystemState.alarmEmailSent.has(cowToken)) {
                        console.log(`üìß [ALARM3 TRIGGER] Sending line2 breach email for ${cowMarker.cowData.cow_nickname || cowToken}`);
                        sendAlarmLine2Email(cowMarker.cowData);
                        alarmSystemState.alarmEmailSent.set(cowToken, true);
                    }
                } else if (zone === 'zone1') {
                    // Cow returned to safe zone
                    if (alarmSystemState.cowAlarmTimers.has(cowToken)) {
                        alarmSystemState.cowAlarmTimers.delete(cowToken);
                        alarmSystemState.alarmEmailSent.delete(cowToken);
                        alarmSystemState.cowsTriggeredReset.delete(cowToken); // Clean up reset tracking
                        console.log(`‚úÖ [COW SAFE] ${cowMarker.cowData.cow_nickname || cowToken} returned to zone1 (INSIDE FENCE)`);
                    }
                }
            });

            // Stop alarm1 only if no cows in zone2 AND no cows in zone3
            // Alarm should continue if cow moves from zone2 to zone3
            if (cowsInZone2.length === 0 && cowsInZone3.length === 0 && alarmSystemState.alarm1Active) {
                console.log('üîï [ALARM1 AUTO-STOP] All cows returned to zone1 - stopping alarm');
                deactivateAlarm1();
            } else if (alarmSystemState.alarm1Active) {
                console.log(`‚è∞ [ALARM1 CONTINUE] ${cowsInZone2.length} cow(s) in zone2, ${cowsInZone3.length} cow(s) in zone3 - alarm continues`);
            }

            // Update the alarm panel UI
            updateAlarmPanelDisplay();
        }

        // Update the real-time alarm panel display
        function updateAlarmPanelDisplay() {
            const alarmList = document.getElementById('alarmList');
            if (!alarmList) return;

            // Collect all active alarms grouped by type
            const esp32Alarms = [];
            const virtualAlarms = [];

            // Check all cows for zone violations
            if (window.currentCows) {
                console.log(`üìä [ALARM PANEL] Checking ${window.currentCows.length} cows for alarms`);

                window.currentCows.forEach(cowMarker => {
                    if (!cowMarker.cowData) return;

                    const cowToken = cowMarker.cowData.cow_token || cowMarker.cowData.collar_id;
                    const zone = alarmSystemState.cowAlarmZones.get(cowToken);

                    if (zone === 'zone2' || zone === 'zone3') {
                        // Use actual_time_outside_fence from database (updated every 10 seconds)
                        let timeOutside = 0;
                        if (cowMarker.cowData.actual_time_outside_fence !== undefined && cowMarker.cowData.actual_time_outside_fence !== null) {
                            // Database value is already real-time (updated every 10 seconds by server)
                            timeOutside = cowMarker.cowData.actual_time_outside_fence;
                        } else {
                            // Fallback to client-side timer calculation
                            const timer = alarmSystemState.cowAlarmTimers.get(cowToken);
                            timeOutside = timer ? Math.floor((Date.now() - timer.enteredAt) / 1000) : 0;
                        }

                        // Determine cow type using isVirtual flag
                        const isVirtual = cowMarker.cowData.isVirtual === true;

                        const cowName = cowMarker.cowData.cow_nickname || cowMarker.cowData.cow_name || cowToken;
                        console.log(`üîç [ALARM DETECTED] ${cowName} (${isVirtual ? 'VIRTUAL' : 'ESP32'}) in ${zone} for ${timeOutside}s - Token: ${cowToken}`);
                        console.log(`   ‚îî‚îÄ cowData.isVirtual: ${cowMarker.cowData.isVirtual}, actual_time_outside_fence: ${cowMarker.cowData.actual_time_outside_fence}, zone_changed_at: ${cowMarker.cowData.zone_changed_at}`);

                        const alarmData = {
                            cowName: cowName,
                            zone: zone === 'zone2' ? 'Zone2' : 'Zone3',
                            timeOutside: timeOutside
                        };

                        if (isVirtual) {
                            virtualAlarms.push(alarmData);
                        } else {
                            esp32Alarms.push(alarmData);
                        }
                    }
                });
            }

            // Update the UI
            console.log(`üìã [ALARM SUMMARY] ESP32: ${esp32Alarms.length}, Virtual: ${virtualAlarms.length}`);

            if (esp32Alarms.length === 0 && virtualAlarms.length === 0) {
                alarmList.innerHTML = '<p class="no-alarms">No active alarms</p>';
            } else {
                let html = '';

                // ESP32 Section
                if (esp32Alarms.length > 0) {
                    html += `<div style="margin-bottom: 1rem;">`;
                    html += `<div style="font-weight: bold; color: #3b82f6; margin-bottom: 0.5rem; font-size: 11px;">ESP32</div>`;
                    esp32Alarms.forEach(alarm => {
                        const minutes = Math.floor(alarm.timeOutside / 60);
                        const seconds = alarm.timeOutside % 60;
                        const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        const zoneColor = alarm.zone === 'Zone2' ? '#f59e0b' : '#ef4444';

                        html += `
                            <div style="padding-left: 1rem; margin-bottom: 0.3rem; font-size: 11px; color: white;">
                                <span style="font-weight: 500;">${alarm.cowName}</span>
                                <span style="color: #95a5a6; margin: 0 0.5rem;">‚Ä¢</span>
                                <span>${timeText}</span>
                                <span style="color: #95a5a6; margin: 0 0.5rem;">‚Ä¢</span>
                                <span style="color: ${zoneColor};">${alarm.zone}</span>
                            </div>
                        `;
                    });
                    html += `</div>`;
                }

                // Virtual Cow Section
                if (virtualAlarms.length > 0) {
                    html += `<div style="margin-bottom: 1rem;">`;
                    html += `<div style="font-weight: bold; color: #f59e0b; margin-bottom: 0.5rem; font-size: 11px;">Virtual Cow</div>`;
                    virtualAlarms.forEach(alarm => {
                        const minutes = Math.floor(alarm.timeOutside / 60);
                        const seconds = alarm.timeOutside % 60;
                        const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        const zoneColor = alarm.zone === 'Zone2' ? '#f59e0b' : '#ef4444';

                        html += `
                            <div style="padding-left: 1rem; margin-bottom: 0.3rem; font-size: 11px; color: white;">
                                <span style="font-weight: 500;">${alarm.cowName}</span>
                                <span style="color: #95a5a6; margin: 0 0.5rem;">‚Ä¢</span>
                                <span>${timeText}</span>
                                <span style="color: #95a5a6; margin: 0 0.5rem;">‚Ä¢</span>
                                <span style="color: ${zoneColor};">${alarm.zone}</span>
                            </div>
                        `;
                    });
                    html += `</div>`;
                }

                alarmList.innerHTML = html;
            }
        }

        // Determine which zone a cow is in
        function getCowZone(cowPosition, cowFarmToken = null) {
            if (!window.currentFences || window.currentFences.length === 0) {
                return 'zone1';
            }

            // Find the fence that belongs to this cow's farm
            let fencePolygon = null;

            if (cowFarmToken) {
                // Try to find fence matching cow's farm
                fencePolygon = window.currentFences.find(fence => fence.farmToken === cowFarmToken);

                if (!fencePolygon) {
                    console.warn(`‚ö†Ô∏è [getCowZone] No fence found for cow's farm ${cowFarmToken}, using first fence as fallback`);
                    fencePolygon = window.currentFences[0];
                }
            } else {
                // No farm token provided, use first fence (or selected fence if available)
                fencePolygon = window.currentFences.find(f => f.selected) || window.currentFences[0];
            }

            if (!fencePolygon || !fencePolygon.getLatLngs) {
                return 'zone1';
            }

            // Check if cow is inside fence (zone1)
            const isInside = checkPointInPolygon(cowPosition, fencePolygon);

            if (isInside) {
                return 'zone1';
            }

            // Check distance from fence boundary
            const distanceFromFence = calculateDistanceFromBoundary(cowPosition, fencePolygon);

            // Zone2: 0-50 meters outside fence, Zone3: >50 meters
            return distanceFromFence <= 50 ? 'zone2' : 'zone3';
        }

        // Check if point is inside polygon
        function checkPointInPolygon(point, polygon) {
            const latLngs = polygon.getLatLngs()[0];
            let inside = false;
            const x = point.lat, y = point.lng;

            for (let i = 0, j = latLngs.length - 1; i < latLngs.length; j = i++) {
                const xi = latLngs[i].lat, yi = latLngs[i].lng;
                const xj = latLngs[j].lat, yj = latLngs[j].lng;

                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }

            return inside;
        }

        // Calculate minimum distance from point to polygon boundary
        function calculateDistanceFromBoundary(point, polygon) {
            const latLngs = polygon.getLatLngs()[0];
            let minDistance = Infinity;

            for (let i = 0; i < latLngs.length; i++) {
                const p1 = latLngs[i];
                const p2 = latLngs[(i + 1) % latLngs.length];
                const distance = distanceToSegment(point, p1, p2);
                minDistance = Math.min(minDistance, distance);
            }

            return minDistance;
        }

        // Haversine formula: Calculate accurate distance between two GPS points in meters
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const toRad = (deg) => deg * Math.PI / 180;

            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in meters
        }

        // Calculate distance from point to line segment using Haversine
        function distanceToSegment(point, lineStart, lineEnd) {
            const A = point.lat - lineStart.lat;
            const B = point.lng - lineStart.lng;
            const C = lineEnd.lat - lineStart.lat;
            const D = lineEnd.lng - lineStart.lng;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = lenSq !== 0 ? dot / lenSq : -1;

            let closestLat, closestLng;
            if (param < 0) {
                // Closest point is lineStart
                closestLat = lineStart.lat;
                closestLng = lineStart.lng;
            } else if (param > 1) {
                // Closest point is lineEnd
                closestLat = lineEnd.lat;
                closestLng = lineEnd.lng;
            } else {
                // Closest point is on the line segment
                closestLat = lineStart.lat + param * C;
                closestLng = lineStart.lng + param * D;
            }

            // Use Haversine formula for accurate distance calculation
            return haversineDistance(point.lat, point.lng, closestLat, closestLng);
        }

        // Activate alarm1 (audio)
        async function triggerAlarm1(cowData) {
            const cowToken = cowData.cow_token || cowData.collar_id;
            console.log('üö® [ALARM1 CHECK] Checking database before triggering for cow:', cowData.cow_nickname || cowToken);

            // Check database before triggering
            const alarmState = await getAlarmStateFromDatabase(cowToken);
            if (!alarmState) {
                console.error('‚ùå [ALARM1 BLOCKED] Failed to fetch alarm state from database');
                return;
            }

            if (!alarmState.alarm1.canTrigger) {
                console.log(`‚ö†Ô∏è [ALARM1 BLOCKED] Alarm1 already triggered (state: ${alarmState.alarm1.triggered}) - skipping to prevent repetition`);
                return;
            }

            console.log('‚úÖ [ALARM1 TRIGGER] Database check passed - activating alarm1');

            // Update database to mark alarm1 as triggered
            try {
                const response = await fetch('/api/alarms/alarm1-trigger', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        cowToken: cowToken
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ [ALARM1 DATABASE] Database updated - alarm1_triggered set to 1');
                } else {
                    const error = await response.json();
                    console.error('‚ùå [ALARM1 DATABASE] Failed to update database:', error.error);
                    return; // Don't play audio if database update failed
                }
            } catch (error) {
                console.error('Failed to update alarm1 in database:', error);
                return; // Don't play audio if database update failed
            }

            alarmSystemState.alarm1Active = true;
            alarmSystemState.alarm1StartTime = Date.now();

            // Play audio only if enabled
            if (alarmSystemState.audioEnabled && alarmSystemState.alarmAudioElement) {
                alarmSystemState.alarmAudioElement.currentTime = 0;
                alarmSystemState.alarmAudioElement.loop = true;
                alarmSystemState.alarmAudioElement.play().catch(err => {
                    console.error('Failed to play alarm audio:', err);
                    console.warn('‚ö†Ô∏è Click "Enable Audio" button to hear alarm sounds');
                });
            } else {
                console.warn('‚ö†Ô∏è Alarm audio not enabled - click "Enable Audio" button to hear sounds');
                // Show the prompt again
                const audioPrompt = document.getElementById('audioEnablePrompt');
                if (audioPrompt) {
                    audioPrompt.style.display = 'block';
                }
            }

            // Set timer to stop after 20 seconds
            console.log(`‚è∞ [ALARM1 TIMER] Setting 20-second timer (${alarmSystemState.alarm1Duration}ms)`);
            alarmSystemState.alarm1Timer = setTimeout(() => {
                console.log('‚è∞ [ALARM1 TIMER] 20 seconds elapsed - stopping alarm');
                deactivateAlarm1();
            }, alarmSystemState.alarm1Duration);
        }

        // Reset alarm1 timer
        function resetAlarmTimer(cowData) {
            console.log('üîÑ Alarm1 timer reset for cow:', cowData.cow_nickname || cowData.cow_token);

            if (alarmSystemState.alarm1Timer) {
                console.log('‚è∞ [ALARM1 TIMER] Clearing previous timer');
                clearTimeout(alarmSystemState.alarm1Timer);
            }

            alarmSystemState.alarm1StartTime = Date.now();

            // Restart audio if it was paused and audio is enabled
            if (alarmSystemState.audioEnabled && alarmSystemState.alarmAudioElement && alarmSystemState.alarmAudioElement.paused) {
                alarmSystemState.alarmAudioElement.currentTime = 0;
                alarmSystemState.alarmAudioElement.play().catch(err => {
                    console.error('Failed to play alarm audio:', err);
                });
            }

            console.log(`‚è∞ [ALARM1 TIMER] Resetting 20-second timer (${alarmSystemState.alarm1Duration}ms)`);
            alarmSystemState.alarm1Timer = setTimeout(() => {
                console.log('‚è∞ [ALARM1 TIMER] 20 seconds elapsed after reset - stopping alarm');
                deactivateAlarm1();
            }, alarmSystemState.alarm1Duration);
        }

        // Helper function to fetch alarm state from database
        async function getAlarmStateFromDatabase(cowToken) {
            try {
                const response = await fetch(`/api/alarms/alarm-state/${cowToken}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.error(`Failed to fetch alarm state: ${response.status}`);
                    return null;
                }

                const alarmState = await response.json();
                console.log(`üìä [DATABASE CHECK] Alarm states for ${cowToken}:`, alarmState);
                return alarmState;
            } catch (error) {
                console.error('Error fetching alarm state from database:', error);
                return null;
            }
        }

        // Stop alarm1
        function deactivateAlarm1() {
            console.log('üîï Alarm1 stopped');

            alarmSystemState.alarm1Active = false;
            alarmSystemState.alarm1StartTime = null;

            if (alarmSystemState.alarm1Timer) {
                clearTimeout(alarmSystemState.alarm1Timer);
                alarmSystemState.alarm1Timer = null;
            }

            // Force stop audio - multiple approaches to ensure it stops
            if (alarmSystemState.alarmAudioElement) {
                try {
                    alarmSystemState.alarmAudioElement.pause();
                    alarmSystemState.alarmAudioElement.currentTime = 0;
                    alarmSystemState.alarmAudioElement.loop = false;
                    console.log('‚úì Audio stopped successfully');
                } catch (error) {
                    console.error('Error stopping audio:', error);
                }
            }

            // Also try to stop via ID directly as backup
            const audioElement = document.getElementById('alarm1Audio');
            if (audioElement) {
                try {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                    audioElement.loop = false;
                } catch (error) {
                    console.error('Error stopping audio via ID:', error);
                }
            }

            // Clear the reset tracking set for next alarm cycle
            alarmSystemState.cowsTriggeredReset.clear();
            console.log('‚úì Reset tracking cleared for next alarm cycle');
        }

        // Send zone2 email
        async function sendAlarmZone2Email(cowData) {
            const cowToken = cowData.cow_token || cowData.collar_id;
            console.log('üìß [ALARM2 CHECK] Checking database before sending zone2 email for cow:', cowData.cow_nickname || cowToken);

            // Check database before triggering
            const alarmState = await getAlarmStateFromDatabase(cowToken);
            if (!alarmState) {
                console.error('‚ùå [ALARM2 BLOCKED] Failed to fetch alarm state from database');
                return;
            }

            if (!alarmState.alarm2.canTrigger) {
                console.log(`‚ö†Ô∏è [ALARM2 BLOCKED] Alarm2 already triggered (state: ${alarmState.alarm2.triggered}) - skipping to prevent duplicate email`);
                return;
            }

            console.log('‚úÖ [ALARM2 TRIGGER] Database check passed - sending zone2 email');

            try {
                const response = await fetch('/api/alarms/zone2-breach', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        cowToken: cowData.cow_token,
                        cowName: cowData.cow_name,
                        cowNickname: cowData.cow_nickname,
                        latitude: cowData.gps_latitude,
                        longitude: cowData.gps_longitude,
                        timestamp: new Date().toISOString()
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ [ALARM2 SUCCESS] Zone2 email sent and database updated');
                } else {
                    const error = await response.json();
                    console.error('‚ùå [ALARM2 FAILED]', error.error);
                }
            } catch (error) {
                console.error('Failed to send zone2 email:', error);
            }
        }

        // Send line2 breach email
        async function sendAlarmLine2Email(cowData) {
            const cowToken = cowData.cow_token || cowData.collar_id;
            console.log('üìß [ALARM3 CHECK] Checking database before sending line2 breach email for cow:', cowData.cow_nickname || cowToken);

            // Check database before triggering
            const alarmState = await getAlarmStateFromDatabase(cowToken);
            if (!alarmState) {
                console.error('‚ùå [ALARM3 BLOCKED] Failed to fetch alarm state from database');
                return;
            }

            if (!alarmState.alarm3.canTrigger) {
                console.log(`‚ö†Ô∏è [ALARM3 BLOCKED] Alarm3 already triggered (state: ${alarmState.alarm3.triggered}) - skipping to prevent duplicate email`);
                return;
            }

            console.log('‚úÖ [ALARM3 TRIGGER] Database check passed - sending line2 breach email');

            try {
                const response = await fetch('/api/alarms/line2-breach', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        cowToken: cowData.cow_token,
                        cowName: cowData.cow_name,
                        cowNickname: cowData.cow_nickname,
                        latitude: cowData.gps_latitude,
                        longitude: cowData.gps_longitude,
                        timestamp: new Date().toISOString()
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ [ALARM3 SUCCESS] Line2 breach email sent and database updated');
                } else {
                    const error = await response.json();
                    console.error('‚ùå [ALARM3 FAILED]', error.error);
                }
            } catch (error) {
                console.error('Failed to send line2 breach email:', error);
            }
        }

        // ==================== CREATE VIRTUAL COW FUNCTIONS ====================

        // Modal control functions
        function openCreateCowModal() {
            const modal = document.getElementById('createCowModal');

            // Load farms into dropdown
            loadFarmsIntoModal();

            // Generate and set next auto-name as placeholder
            generateNextCowName().then(nextName => {
                document.getElementById('cowNameInput').placeholder = nextName;
            });

            // Show modal
            modal.classList.add('show');
        }

        function closeCreateCowModal() {
            const modal = document.getElementById('createCowModal');
            modal.classList.remove('show');

            // Reset form
            document.getElementById('createCowForm').reset();
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('createCowModal');
            if (e.target === modal) {
                closeCreateCowModal();
            }
        });

        // Generate next auto-incremented cow name (cow1, cow2, cow3...)
        async function generateNextCowName() {
            try {
                const response = await fetch(`${virtualApiBase}/dev/virtual-cows`, {
                    headers: { 'Authorization': `Bearer ${virtualAuthToken}` }
                });
                const data = await response.json();
                const virtualCows = data.virtualCows || [];

                // Find highest number from existing cow names (cow1, cow2, etc.)
                let maxNumber = 0;
                virtualCows.forEach(cow => {
                    const match = cow.cow_name.match(/^cow(\d+)$/);
                    if (match) {
                        const num = parseInt(match[1]);
                        if (num > maxNumber) {
                            maxNumber = num;
                        }
                    }
                });

                return `cow${maxNumber + 1}`;
            } catch (error) {
                console.error('Error generating cow name:', error);
                return 'cow1'; // Default fallback
            }
        }

        // Refresh all cow positions from database
        async function refreshCowPositions() {
            console.log('\n========================================');
            console.log('üîÑ [Page19] REFRESHING COW POSITIONS');
            console.log('========================================');

            try {
                console.log('üì° Fetching from:', `${virtualApiBase}/dev/virtual-cows`);
                const response = await fetch(`${virtualApiBase}/dev/virtual-cows`, {
                    headers: { 'Authorization': `Bearer ${virtualAuthToken}` }
                });

                console.log('Response status:', response.status);

                if (!response.ok) {
                    console.error('‚ùå Failed to fetch cow data. Status:', response.status);
                    alert('Failed to fetch cow data from server');
                    return;
                }

                const data = await response.json();
                const virtualCows = data.virtualCows || [];

                console.log(`‚úÖ Fetched ${virtualCows.length} cows from database`);
                console.log('\nüìä DATABASE COW DATA:');
                virtualCows.forEach(cow => {
                    console.log(`  - ${cow.cow_name}:`);
                    console.log(`    Token: ${cow.cow_token}`);
                    console.log(`    Position: (${cow.gps_latitude}, ${cow.gps_longitude})`);
                    console.log(`    Zone: ${cow.state_fence}`);
                });

                console.log('\nüîÑ Updating map markers...');
                let updatedCount = 0;

                // Update each cow marker with latest database position
                virtualCows.forEach(cow => {
                    const cowMarker = window.currentCows.find(m => m.cowData && m.cowData.cow_token === cow.cow_token);

                    if (cowMarker && cow.gps_latitude && cow.gps_longitude) {
                        console.log(`\n  Updating ${cow.cow_nickname || cow.cow_name}:`);
                        console.log(`    Old position: (${cowMarker.getLatLng().lat}, ${cowMarker.getLatLng().lng})`);
                        console.log(`    New position: (${cow.gps_latitude}, ${cow.gps_longitude})`);
                        console.log(`    Old zone: ${cowMarker.cowData?.state_fence}`);
                        console.log(`    New zone: ${cow.state_fence}`);

                        // Update marker position
                        cowMarker.setLatLng([cow.gps_latitude, cow.gps_longitude]);

                        // Update stored cow data
                        if (cowMarker.cowData) {
                            cowMarker.cowData.gps_latitude = cow.gps_latitude;
                            cowMarker.cowData.gps_longitude = cow.gps_longitude;
                            cowMarker.cowData.state_fence = cow.state_fence;
                            cowMarker.cowData.real_time_coordinate = `${cow.gps_latitude},${cow.gps_longitude}`;
                        }

                        console.log(`    ‚úÖ Marker updated!`);
                        updatedCount++;
                    } else if (!cowMarker) {
                        console.warn(`    ‚ö†Ô∏è No marker found for ${cow.cow_name}`);
                    } else {
                        console.warn(`    ‚ö†Ô∏è Missing GPS for ${cow.cow_name}`);
                    }
                });

                console.log(`\n‚úÖ Updated ${updatedCount} out of ${virtualCows.length} cows`);
                console.log('========================================\n');

                // Show success notification
                alert(`Cow positions refreshed! ${updatedCount} cows updated from database.`);
            } catch (error) {
                console.error('‚ùå ERROR refreshing cow positions:', error);
                console.error('Error details:', error.message);
                console.error('Stack:', error.stack);
                alert('Failed to refresh cow positions: ' + error.message);
            }
        }

        // Load farms into modal dropdown
        async function loadFarmsIntoModal() {
            try {
                const response = await fetch(`${virtualApiBase}/dev/farms`, {
                    headers: { 'Authorization': `Bearer ${virtualAuthToken}` }
                });

                if (response.ok) {
                    const data = await response.json();
                    const farms = data.farms || [];

                    const select = document.getElementById('farmSelectModal');

                    // Keep the "No Farm" option and add farms
                    let options = '<option value="">-- No Farm (0,0 position) --</option>';
                    farms.forEach(farm => {
                        options += `<option value="${farm.farm_token}">${farm.farm_name}</option>`;
                    });

                    select.innerHTML = options;
                }
            } catch (error) {
                console.error('Error loading farms:', error);
            }
        }

        // Calculate fence center for a given farm
        function getFenceCenterForFarm(farmToken) {
            // If no farm selected, return 0,0
            if (!farmToken) {
                return { lat: 0.0, lng: 0.0 };
            }

            // Find fence polygon for this farm (check if fence has farmToken attached)
            const fencePolygon = window.currentFences.find(fence => {
                return fence.farmToken === farmToken;
            });

            if (!fencePolygon || !fencePolygon.getLatLngs) {
                console.warn('No fence found for farm, using 0,0');
                return { lat: 0.0, lng: 0.0 };
            }

            // Calculate centroid
            const latLngs = fencePolygon.getLatLngs()[0];

            if (!latLngs || latLngs.length === 0) {
                return { lat: 0.0, lng: 0.0 };
            }

            let sumLat = 0;
            let sumLng = 0;

            latLngs.forEach(point => {
                sumLat += point.lat;
                sumLng += point.lng;
            });

            const centerLat = sumLat / latLngs.length;
            const centerLng = sumLng / latLngs.length;

            console.log(`Fence center for farm: (${centerLat.toFixed(6)}, ${centerLng.toFixed(6)})`);

            return { lat: centerLat, lng: centerLng };
        }

        // Set initial position for newly created virtual cow
        async function setVirtualCowInitialPosition(cowToken, latitude, longitude) {
            try {
                const response = await fetch(`${virtualApiBase}/dev/virtual-cows/${cowToken}/position`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        latitude: latitude,
                        longitude: longitude,
                        speed: 0
                    })
                });

                if (response.ok) {
                    console.log(`Initial position set for ${cowToken}: (${latitude}, ${longitude})`);
                } else {
                    console.error('Failed to set initial position');
                }
            } catch (error) {
                console.error('Error setting initial position:', error);
            }
        }

        // Handle create cow form submission
        async function handleCreateCow(event) {
            event.preventDefault();

            const cowNameInput = document.getElementById('cowNameInput').value.trim();
            const farmToken = document.getElementById('farmSelectModal').value;

            // Use custom name or generate auto name
            let cowName = cowNameInput;
            if (!cowName) {
                cowName = await generateNextCowName();
            }

            // Calculate initial position
            const initialPosition = getFenceCenterForFarm(farmToken);

            console.log(`Creating virtual cow: ${cowName}, Farm: ${farmToken || 'None'}, Position: (${initialPosition.lat}, ${initialPosition.lng})`);

            try {
                // Call API to create virtual cow
                const response = await fetch(`${virtualApiBase}/dev/virtual-cows`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        cowName: cowName,
                        cowNickname: cowName, // Use same name for nickname
                        farmToken: farmToken || null
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const newCow = data.virtualCow;

                    console.log('Virtual cow created successfully:', newCow);

                    // Set initial position if not 0,0
                    if (initialPosition.lat !== 0 || initialPosition.lng !== 0) {
                        await setVirtualCowInitialPosition(newCow.cow_token, initialPosition.lat, initialPosition.lng);
                    }

                    // Close modal
                    closeCreateCowModal();

                    // Refresh virtual cow list in dropdown
                    await loadVirtualCows();

                    // Reload map to show new cow
                    // First, check if cow already exists on map and update it
                    const existingMarker = window.currentCows.find(m =>
                        m.cowData && (
                            m.cowData.cow_token === newCow.cow_token ||
                            m.cowData.collar_id === newCow.collar_id
                        )
                    );

                    if (existingMarker) {
                        console.log(`Found existing marker for newly created cow, updating to virtual`);
                        existingMarker.cowData.isVirtual = true;

                        // Update marker position if needed
                        if (initialPosition.lat !== 0 || initialPosition.lng !== 0) {
                            existingMarker.setLatLng([initialPosition.lat, initialPosition.lng]);
                        }
                    } else {
                        console.log(`No existing marker found, loading virtual cows on map`);
                        await loadVirtualCowsOnMap();
                    }

                    // Auto-select the newly created cow
                    const select = document.getElementById('virtualCowSelect');
                    select.value = newCow.cow_token;
                    select.dispatchEvent(new Event('change'));

                    // Show success message
                    alert(`Virtual cow "${newCow.cow_name}" created successfully!`);
                } else {
                    const error = await response.json();
                    alert(`Failed to create cow: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Error creating virtual cow:', error);
                alert('Failed to create virtual cow. Please try again.');
            }
        }

        // ============================================
        // COW RECOVERY MODAL FUNCTIONS
        // ============================================

        let selectedCowsForRecovery = new Set();

        /**
         * Open the cow recovery modal
         */
        async function openRecoveryModal() {
            const modal = document.getElementById('cowRecoveryModal');
            modal.style.display = 'flex';

            // Load farms into dropdown
            await loadFarmsForRecovery();

            // Reset selections
            selectedCowsForRecovery.clear();
            document.getElementById('startRecoveryBtn').disabled = true;
        }

        /**
         * Close the cow recovery modal
         */
        function closeRecoveryModal() {
            const modal = document.getElementById('cowRecoveryModal');
            modal.style.display = 'none';
            selectedCowsForRecovery.clear();
        }

        /**
         * Load farms into the recovery farm selector
         */
        async function loadFarmsForRecovery() {
            try {
                const response = await fetch(`${virtualApiBase}/dev/farms`, {
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`
                    }
                });

                if (!response.ok) {
                    console.error('Failed to load farms for recovery');
                    return;
                }

                const data = await response.json();
                const farms = data.farms || [];

                const select = document.getElementById('recoveryFarmSelect');
                select.innerHTML = '<option value="">-- Select Farm --</option>';

                farms.forEach(farm => {
                    const option = document.createElement('option');
                    option.value = farm.farm_token;
                    option.textContent = farm.farm_name;
                    select.appendChild(option);
                });

            } catch (error) {
                console.error('Error loading farms for recovery:', error);
            }
        }

        /**
         * Load cows outside fence for selected farm
         */
        async function loadCowsForRecovery() {
            const farmToken = document.getElementById('recoveryFarmSelect').value;
            const cowListContainer = document.getElementById('recoveryCowList');

            if (!farmToken) {
                cowListContainer.innerHTML = `
                    <p style="color: #95a5a6; text-align: center; padding: 2rem;">
                        Select a farm to see cows outside the fence
                    </p>
                `;
                selectedCowsForRecovery.clear();
                document.getElementById('startRecoveryBtn').disabled = true;
                return;
            }

            try {
                // Get all cows for this farm from dbt4 and dbt6
                const response = await fetch(`${virtualApiBase}/dev/virtual-cows`, {
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`
                    }
                });

                if (!response.ok) {
                    console.error('Failed to load cows');
                    return;
                }

                const data = await response.json();
                let allCows = data.virtualCows || [];

                console.log('=== COW RECOVERY DEBUG ===');
                console.log('Selected farmToken:', farmToken);
                console.log('Total cows from API:', allCows.length);
                console.log('All cows:', allCows);

                // Filter cows for this farm and calculate their real-time zone
                const cowsOutsideFence = [];

                allCows.forEach(cow => {
                    const matchesFarm = cow.farm_token === farmToken;

                    if (!matchesFarm) {
                        console.log(`Cow: ${cow.cow_name}, farm_token: ${cow.farm_token}, state_fence: ${cow.state_fence}, matches farm: false`);
                        return;
                    }

                    // Find the cow marker on the map to check its real-time zone
                    let zone = null;
                    const cowMarker = window.virtualCowMarkers?.find(m => m.cowData?.cow_token === cow.cow_token);

                    if (cowMarker && window.currentFences && window.currentFences.length > 0) {
                        const cowPosition = cowMarker.getLatLng();
                        // Check against the cow's OWN farm's fence
                        zone = getCowZone(cowPosition, cow.farm_token);
                        console.log(`Cow: ${cow.cow_name}, farm_token: ${cow.farm_token}, real-time zone: ${zone}, outside fence: ${zone === 'zone2' || zone === 'zone3'}`);

                        if (zone === 'zone2' || zone === 'zone3') {
                            cowsOutsideFence.push({ ...cow, realTimeZone: zone });
                        }
                    } else {
                        // Fallback: if cow has GPS and fence exists, calculate zone
                        if (cow.gps_latitude && cow.gps_longitude && window.currentFences && window.currentFences.length > 0) {
                            const cowPosition = { lat: cow.gps_latitude, lng: cow.gps_longitude };
                            // Check against the cow's OWN farm's fence
                            zone = getCowZone(cowPosition, cow.farm_token);
                            console.log(`Cow: ${cow.cow_name}, farm_token: ${cow.farm_token}, calculated zone: ${zone}, outside fence: ${zone === 'zone2' || zone === 'zone3'}`);

                            if (zone === 'zone2' || zone === 'zone3') {
                                cowsOutsideFence.push({ ...cow, realTimeZone: zone });
                            }
                        } else {
                            console.log(`Cow: ${cow.cow_name}, farm_token: ${cow.farm_token}, state_fence: ${cow.state_fence}, no GPS or fence - skipped`);
                        }
                    }
                });

                console.log('Cows outside fence for this farm:', cowsOutsideFence.length);
                console.log('Filtered cows:', cowsOutsideFence);
                console.log('=== END DEBUG ===');

                // Display cows
                if (cowsOutsideFence.length === 0) {
                    cowListContainer.innerHTML = `
                        <p style="color: #95a5a6; text-align: center; padding: 2rem;">
                            No cows outside the fence for this farm
                        </p>
                    `;
                    selectedCowsForRecovery.clear();
                    document.getElementById('startRecoveryBtn').disabled = true;
                    return;
                }

                cowListContainer.innerHTML = '';

                cowsOutsideFence.forEach(cow => {
                    const cowItem = document.createElement('div');
                    cowItem.className = 'cow-checkbox-item';
                    cowItem.onclick = () => toggleCowSelection(cow.cow_token, cowItem);

                    const zoneClass = cow.realTimeZone === 'zone2' ? 'zone2' : 'zone3';
                    const zoneText = cow.realTimeZone === 'zone2' ? 'Zone 2' : 'Zone 3';

                    cowItem.innerHTML = `
                        <input type="checkbox" id="cow-${cow.cow_token}" onclick="event.stopPropagation(); toggleCowSelection('${cow.cow_token}', this.parentElement);">
                        <div class="cow-checkbox-info">
                            <div class="cow-name">${cow.cow_name || cow.cow_nickname || cow.collar_id}</div>
                            <div class="cow-status">
                                Collar: ${cow.collar_id}
                                <span class="zone-badge ${zoneClass}">${zoneText}</span>
                            </div>
                        </div>
                    `;

                    cowListContainer.appendChild(cowItem);
                });

                // Reset selections
                selectedCowsForRecovery.clear();
                document.getElementById('startRecoveryBtn').disabled = true;

            } catch (error) {
                console.error('Error loading cows for recovery:', error);
                cowListContainer.innerHTML = `
                    <p style="color: #e74c3c; text-align: center; padding: 2rem;">
                        Error loading cows. Please try again.
                    </p>
                `;
            }
        }

        /**
         * Toggle cow selection
         */
        function toggleCowSelection(cowToken, element) {
            const checkbox = element.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;

            if (checkbox.checked) {
                selectedCowsForRecovery.add(cowToken);
            } else {
                selectedCowsForRecovery.delete(cowToken);
            }

            // Enable/disable start recovery button
            document.getElementById('startRecoveryBtn').disabled = selectedCowsForRecovery.size === 0;
        }

        /**
         * Start recovery session
         */
        async function startRecovery() {
            if (selectedCowsForRecovery.size === 0) {
                alert('Please select at least one cow for recovery');
                return;
            }

            const farmToken = document.getElementById('recoveryFarmSelect').value;
            if (!farmToken) {
                alert('Please select a farm');
                return;
            }

            try {
                const requestBody = {
                    farmToken: farmToken,
                    lostCowTokens: Array.from(selectedCowsForRecovery),
                    expiresIn: 24 // 24 hours
                };

                console.log('=== RECOVERY REQUEST ===');
                console.log('API Endpoint:', `${virtualApiBase}/recovery/virtual/create`);
                console.log('Auth Token:', virtualAuthToken ? 'Present' : 'Missing');
                console.log('Request Body:', requestBody);
                console.log('=======================');

                // Call API to create recovery session
                const response = await fetch(`${virtualApiBase}/recovery/virtual/create`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${virtualAuthToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    console.error('=== RECOVERY ERROR ===');
                    console.error('Status:', response.status);
                    console.error('Error:', error);
                    console.error('=====================');
                    alert(`Failed to create recovery: ${error.error || 'Unknown error'}\n\nDetails: ${error.details || 'Check console for more info'}`);
                    return;
                }

                const data = await response.json();

                // Close modal
                closeRecoveryModal();

                // Open page 18 in new window with recovery ID
                const recoveryUrl = `/html/page18_dev-assistive-collaboration.html?recoveryId=${data.recoveryId}`;
                window.open(recoveryUrl, '_blank');

                // Show success message
                alert(`Recovery created successfully!\nRecovery Code: ${data.recoveryCode}\nRecovery ID: ${data.recoveryId}\n\nPage 18 has been opened in a new window.`);

            } catch (error) {
                console.error('Error starting recovery:', error);
                alert('Failed to start recovery. Please try again.');
            }
        }
    </script>
</body>
</html>
